مرور دقیق کلاس UserService

کلاس UserService به عنوان لایه میانی بین endpointهای API و لایه دسترسی به داده (CRUD) عمل می‌کند و منطق تجاری مربوط به کاربران را در خود جای داده است.

__init__(self, db_session: AsyncSession):

هنگام ایجاد یک نمونه از UserService (معمولاً از طریق یک وابستگی FastAPI)، یک جلسه پایگاه داده آسنکرون (AsyncSession) به آن تزریق می‌شود.

این جلسه پایگاه داده برای ایجاد یک نمونه از CRUDUser استفاده می‌شود که در تمام متدهای دیگر سرویس برای تعامل با پایگاه داده به کار می‌رود.

async def register_user(self, *, user_in: UserCreate) -> User:

وظیفه: ثبت‌نام یک کاربر جدید.

مراحل:

با استفاده از crud_user، بررسی می‌کند که آیا نام کاربری (user_in.username) یا ایمیل (user_in.email) قبلاً در سیستم ثبت شده است یا خیر.

اگر تکراری بود، استثنای DuplicateResourceException را ایجاد می‌کند (که توسط error handler مرکزی به پاسخ HTTP مناسب تبدیل می‌شود).

رمز عبور خام (user_in.password) را با استفاده از get_password_hash (از src.core.security) هش می‌کند.

یک نمونه از اسکیمای داخلی UserCreateInternal با تمام اطلاعات لازم (شامل رمز عبور هش شده، و مقادیر پیش‌فرض برای is_active=True، is_superuser از ورودی، و is_email_verified=False) ایجاد می‌کند.

کاربر جدید را با استفاده از crud_user.db_create_user در پایگاه داده ذخیره می‌کند.

شیء کاربر ایجاد شده را برمی‌گرداند.

نکته ایمیل: در این مرحله، کاربر ایجاد شده اما ایمیل او هنوز تأیید نشده است. Endpoint مربوط به API که این متد را فراخوانی می‌کند، مسئولیت دارد که پس از ایجاد موفق کاربر، فرآیند ارسال ایمیل تأیید را (با استفاده از prepare_email_verification_data و BackgroundTasks) آغاز کند.

async def authenticate_user(self, *, username: str, password: str, client_ip: str | None = None) -> User:

وظیفه: احراز هویت کاربر برای لاگین.

مراحل:

کاربر را با نام کاربری از طریق crud_user.get_user_by_username بازیابی می‌کند.

اگر کاربر پیدا نشد، AuthenticationFailedException ایجاد می‌کند.

رمز عبور ارائه شده را با رمز عبور هش شده ذخیره شده با استفاده از verify_password (از src.core.security) مقایسه می‌کند. اگر مطابقت نداشت، AuthenticationFailedException ایجاد می‌کند.

بررسی می‌کند که آیا کاربر فعال است (user.is_active). اگر نه، AuthenticationFailedException ایجاد می‌کند (در اینجا می‌توان شرط تأیید ایمیل را نیز اضافه کرد).

فیلدهای last_login_at را با زمان فعلی UTC (ناآگاه از منطقه زمانی) و last_login_ip (اگر ارائه شده باشد) به‌روز می‌کند.

این تغییرات را با استفاده از crud_user.update_user در پایگاه داده ذخیره می‌کند (این کار updated_at را نیز به‌روز می‌کند).

شیء کاربر احراز هویت شده را برمی‌گرداند.

async def get_user_by_id(self, *, user_id: UUID) -> User:

کاربر را با شناسه از طریق crud_user بازیابی می‌کند.

اگر کاربر پیدا نشد، UserNotFoundException ایجاد می‌کند.

async def get_user_profile(self, *, current_user: User) -> User:

اطلاعات پروفایل کاربر لاگین کرده فعلی را برمی‌گرداند. در حال حاضر، فقط خود شیء current_user (که از قبل توسط وابستگی get_current_active_user واکشی و اعتبارسنجی شده) را برمی‌گرداند.

async def update_user_profile(self, *, current_user: User, user_in: UserUpdate) -> User:

پروفایل کاربر لاگین کرده فعلی را به‌روز می‌کند.

داده‌های ورودی (user_in) را برای به‌روزرسانی آماده می‌کند.

اگر ایمیل در حال تغییر است، بررسی می‌کند که ایمیل جدید توسط کاربر دیگری استفاده نشده باشد و is_email_verified را False می‌کند.

اگر نام کاربری در حال تغییر است، بررسی می‌کند که نام کاربری جدید توسط کاربر دیگری استفاده نشده باشد.

از تغییر رمز عبور از طریق این متد جلوگیری می‌کند.

کاربر را با crud_user.update_user به‌روز می‌کند.

async def change_password(self, *, current_user: User, password_in: UserUpdatePassword) -> User:

رمز عبور کاربر لاگین کرده فعلی را تغییر می‌دهد.

ابتدا رمز عبور فعلی ارائه شده را با رمز عبور ذخیره شده تأیید می‌کند.

بررسی می‌کند که رمز عبور جدید با رمز عبور فعلی یکسان نباشد.

رمز عبور جدید را هش کرده و کاربر را به‌روز می‌کند.

async def prepare_password_reset_data(self, *, email_in: PasswordResetRequest) -> Tuple[User | None, str | None, str]:

وظیفه: داده‌های لازم برای فرآیند بازیابی رمز عبور را آماده می‌کند (اما خود ایمیل را ارسال نمی‌کند).

مراحل:

کاربر را با ایمیل از طریق crud_user پیدا می‌کند.

اگر کاربر پیدا نشد یا فعال نبود، برای جلوگیری از شمارش ایمیل (email enumeration)، یک پیام عمومی به کلاینت برمی‌گرداند و کاربر و توکن را None برمی‌گرداند. (در لاگ سرور می‌توان جزئیات بیشتری ثبت کرد).

یک توکن بازنشانی رمز عبور JWT (با نوع "password_reset" و تاریخ انقضای مشخص شده در تنظیمات) با استفاده از create_access_token ایجاد می‌کند.

هش این توکن بازنشانی و تاریخ انقضای آن را در رکورد کاربر در پایگاه داده ذخیره می‌کند (با استفاده از crud_user.update_user).

شیء کاربر، توکن بازنشانی خام (نه هش شده) و پیام برای کلاینت را برمی‌گرداند. Endpoint مربوطه از این توکن خام برای ارسال ایمیل استفاده خواهد کرد.

async def confirm_password_reset(self, *, token_in: str, new_password_in: PasswordResetConfirm) -> User:

وظیفه: رمز عبور کاربر را با استفاده از توکن بازنشانی تأیید و به‌روز می‌کند.

مراحل:

توکن بازنشانی (token_in) را با decode_token رمزگشایی و اعتبارسنجی می‌کند (بررسی نوع "password_reset" و تاریخ انقضا).

کاربر را از sub (شناسه کاربر) و email موجود در payload توکن بازیابی می‌کند.

بررسی می‌کند که آیا توکن بازنشانی در پایگاه داده برای این کاربر وجود دارد و منقضی نشده باشد.

توکن ارائه شده (token_in) را با هش توکن ذخیره شده در پایگاه داده (user.reset_token) با استفاده از verify_password مقایسه می‌کند.

اگر همه چیز معتبر بود، رمز عبور جدید را هش کرده، رمز عبور کاربر را به‌روز می‌کند و توکن بازنشانی را از پایگاه داده پاک (باطل) می‌کند.

معمولاً پس از بازنشانی موفق رمز عبور، is_email_verified نیز True در نظر گرفته می‌شود.

async def prepare_email_verification_data(self, *, current_user: User) -> Tuple[User, str, str]:

وظیفه: داده‌های لازم برای ارسال ایمیل تأیید را برای کاربر لاگین کرده فعلی آماده می‌کند.

مراحل:

بررسی می‌کند که آیا ایمیل کاربر قبلاً تأیید شده یا کاربر غیرفعال است یا خیر.

یک توکن تأیید ایمیل JWT (با نوع "email_verification" و تاریخ انقضای مشخص) ایجاد می‌کند.

هش این توکن را در فیلد email_verification_token کاربر در پایگاه داده ذخیره می‌کند.

شیء کاربر به‌روز شده، توکن تأیید خام و پیام برای کلاینت را برمی‌گرداند.

async def confirm_email_verification(self, *, token_in: str) -> User:

وظیفه: ایمیل کاربر را با استفاده از توکن تأیید، تأیید می‌کند.

مراحل:

توکن (token_in) را رمزگشایی و اعتبارسنجی می‌کند.

کاربر را از payload توکن بازیابی می‌کند.

بررسی می‌کند که آیا ایمیل کاربر قبلاً تأیید شده است یا خیر.

بررسی می‌کند که آیا توکن تأیید در پایگاه داده برای این کاربر وجود دارد یا خیر.

توکن ارائه شده را با هش توکن ذخیره شده در پایگاه داده مقایسه می‌کند.

اگر معتبر بود، is_email_verified را True، email_verified_at را با زمان فعلی، و is_active را (در صورت نیاز) True تنظیم کرده و توکن تأیید را از پایگاه داده پاک می‌کند.

async def soft_delete_user(self, *, user_to_delete_id: UUID, performing_user: User) -> User:

حذف نرم یک کاربر را انجام می‌دهد.

بررسی می‌کند که آیا کاربر حذف‌کننده (performing_user) مجوز لازم را دارد (یا خودش است یا superuser).

بررسی می‌کند که آیا کاربر قبلاً حذف نرم نشده باشد.

نکته مهم: شامل یک placeholder برای بررسی اینکه آیا کاربر فرمانده یک حادثه فعال است یا خیر (این منطق باید بعداً با استفاده از crud_incident پیاده‌سازی شود).

فیلدهای is_deleted, deleted_at, و is_active کاربر را به‌روز می‌کند.

async def get_users_list(self, *, skip: int = 0, limit: int = 100) -> List[User]:

لیستی از کاربران را (معمولاً برای پنل ادمین) با صفحه‌بندی برمی‌گرداند.

نکات کلیدی:

این لایه سرویس به خوبی منطق تجاری را از لایه API و لایه CRUD جدا می‌کند.

از استثناهای سفارشی برای گزارش خطاها استفاده می‌کند.

برای عملیات حساس مانند بازیابی رمز عبور و تأیید ایمیل، از توکن‌های JWT با نوع و تاریخ انقضای مشخص استفاده می‌کند و هش توکن‌ها را در پایگاه داده ذخیره می‌کند (به جای خود توکن خام) که یک رویه امنیتی خوب است.

ارسال واقعی ایمیل‌ها به لایه API (با استفاده از BackgroundTasks) واگذار شده است.

این مرور باید به شما درک دقیق‌تری از عملکرد UserService بدهد. آیا بخش خاصی وجود دارد که می‌خواهید بیشتر در مورد آن صحبت کنیم یا به سراغ پیاده‌سازی بخش بعدی (احتمالاً endpointها یا وابستگی‌ها) برویم؟
